# Shell

+ 脚本语言：不需要编译，直接逐行执行
+ 解释性语言：适合编写自动化任务

## shell分类

流行的shell有ash、bash、ksh、csh、zsh等，不同的shell都有各自的特点及用途

+ Linux中默认的shell是/bin/bash

### 编写规范

```shell
#!/bin/bash #表示告知系统要使用的shell解释器
相关命令
```

### 文件命名规范

`file.sh`

#### Bash 常用快捷键

| 快捷键     | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| `Ctrl + A` | 把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移动到命令行开头时使用。 |
| `Ctrl + E` | 把光标移动到命令行结尾。                                     |
| `Ctrl + C` | 强制终止当前的命令。                                         |
| `Ctrl + L` | 清屏，相当于 `clear` 命令。                                  |
| `Ctrl + U` | 删除或剪切光标之前的命令。对于很长的命令，可以快速删除而无需使用退格键。 |
| `Ctrl + K` | 删除或剪切光标之后的内容。                                   |
| `Ctrl + Y` | 粘贴 `Ctrl + U` 或 `Ctrl + K` 剪切的内容。                   |
| `Ctrl + R` | 在历史命令中搜索，按下 `Ctrl + R` 后输入搜索内容即可查找历史命令。 |
| `Ctrl + D` | 退出当前终端。                                               |
| `Ctrl + Z` | 暂停当前命令，并放入后台。与工作管理相关，在系统管理章节详细介绍。 |
| `Ctrl + S` | 暂停屏幕输出。                                               |
| `Ctrl + Q` | 恢复屏幕输出。                                               |

### 输入输出重定向

#### 标准输入输出

| 设备   | 设备名      | 文件描述符 | 类型         |
| ------ | ----------- | ---------- | ------------ |
| 键盘   | /dev/stdin  | 0          | 标准输入     |
| 显示器 | /dev/stdout | 1          | 标准输出     |
| 显示器 | /dev/stderr | 2          | 标准错误输出 |

#### 输入重定向

| 类型                       | 符号（语法）       | 功能                                                 |
| -------------------------- | ------------------ | ---------------------------------------------------- |
| 标准输入                   | 命令<文件1         | 命令把文件1的内容作为标准输入设备                    |
| 标识符限定输入             | 命令<<标识符       | 命令把标准输入中读入内容，直到遇到“标识符”分解符为止 |
| 输入输出重定向（同时使用） | 命令< 文件1 >文件2 | 命令把文件1的内容作为标准输入，把文件2作为标准输出。 |

#### 输出重定向

| 类型                       | 符号                      | 作用                                                       |
| -------------------------- | ------------------------- | ---------------------------------------------------------- |
| 标准输出重定向             | `命令 > 文件`             | 以覆盖方式，将命令的正确输出内容保存到指定的文件或设备中。 |
| 标准输出重定向             | `命令 >> 文件`            | 以追加方式，将命令的正确输出内容保存到指定的文件或设备中。 |
| 标准错误输出重定向         | `错误命令 2> 文件`        | 以覆盖方式，将命令的错误输出保存到指定的文件或设备中。     |
| 标准错误输出重定向         | `错误命令 2>> 文件`       | 以追加方式，将命令的错误输出保存到指定的文件或设备中。     |
| 正确输出和错误输出同时保存 | `命令 > 文件 2>&1`        | 以覆盖方式，将正确输出和错误输出都保存到同一个文件中。     |
| 正确输出和错误输出同时保存 | `命令 >> 文件 2>&1`       | 以追加方式，将正确输出和错误输出都保存到同一个文件中。     |
| 正确输出和错误输出同时保存 | `命令 &> 文件`            | 以覆盖方式，将正确输出和错误输出都保存到同一个文件中。     |
| 正确输出和错误输出同时保存 | `命令 &>> 文件`           | 以追加方式，将正确输出和错误输出都保存到同一个文件中。     |
| 正确输出和错误输出分别保存 | `命令 >> 文件1 2>> 文件2` | 将正确输出追加到文件1中，将错误输出追加到文件2中。         |

#### /dev/null 文件

+ 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到**/dev/null**中
  `command > dev/null`

### 多命令执行顺序

| 多命令执行符 | 格式           | 作用                                                         |
| ------------ | -------------- | ------------------------------------------------------------ |
| ；           | 命令1 ；命令2  | 多个命令顺序执行，命令之间没有任何逻辑联系                   |
| &&           | 命令1&&命令2   | 当命令1正确执行（? = 0 ） ， 则 命 令 2 才 会 执 行 当 命 令 1 执 行 不 正 确 （ ?=0），则命令2才会执行 当命令1执行不正确（?=0），则命令2才会执行当命令1执行不正确（?≠0），则命令2不会执行 |
| \|\|         | 命令1\|\|命令2 | 当命令1执行不正确（? ≠ 0 ） ， 则 命 令 2 才 会 执 行 当 命 令 1 正 确 执 行 （ ?≠0），则命令2才会执行当命令1正确执行（? <br/>\\<br/><br/> =0），则命令2才会执行当命令1正确执行（?=0），则命令2不会执行 |

### 执行shell脚本

1. 给文件增加执行权限

   ```shell
   chmod +x myshell.sh
   ./myshel.sh
   ```

2. 通过Bash调用执行脚本

   ```shell
   bash myshell.sh
   ```

   

## shell变量

### 命名规则

> 1. 首字符不能数字开头，是能使用英文字母，数字和下划线
>
> 2. 等号左右两侧不能有空格，可以使用下划线'_'，变量的值如果有空格，需要使用单引号或者双引号包括。
>    `test="hello world!"`
>
> 3. 不能使用标点符号，不能使用关键字（help查看保留关键字）
>
> 4. 环境变量建议大写，便于区分
>
> 5. 如果需要增加变量的值，可以进行变量值的叠加。不过变量需要双引号包含”&变量名“或用￥{变量名}包含变量名。
>
>    ```shell
>    test=123
>    test="$test"456
>    echo $test #123456
>    test=${test}789
>    echo $test #123456789
>    ```

+ 单双引号
  + 双引号能够识别变量，双引号能够实现转义（类似于\\*”）
  + 单引号是不能识别变量，只会原样输出，单引号不能转义

#### shell中特殊符号



| 符号 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| ’ ’  | 单引号。在单引号中所有的特殊符号，如“$”和”(反引号)都没有特殊含义。单引号括起来的都是普通字符，会原样输出 |
| " "  | 双引号。在双引号中特殊符号都没有特殊含义，但是“$”，"`"（esc键下面）和“\”是例外，拥有“调用变量的值”、“引用命令”和“转义符”的特殊含义。 |
| ``   | 反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和( ) 作 用 一 样 ，不过推荐使用()，因为反引号非常容易看错 |
| $()  | 和反引号作用一样，用来引用系统命令。(推荐使用)               |
| ()   | 用于一串命令执行时，()中的命令会在子Shell中运行              |
| {}   | 用于一串命令执行时，{ }中的命令会在当前Shell中执行。也可以用于变量变形与替换。 |
| [ ]  | 用于变量的测试。                                             |
| #    | 在Shell脚本中，#开头的行代表注释。                           |
| $    | 用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值。 |
| \    | 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如$将输出“$”符号，而不当做是变量引用。 |


#### 单双引号

```shell
[root@localhost ~]$ name=sc
#定义变量name 的值是sc
[root@localhost ~]$ echo '$name'
$name
#如果输出时使用单引号，则$name原封不动的输出
[root@localhost ~]$ echo "$name"
sc
#如果输出时使用双引号，则会输出变量name的值 sc

[root@localhost ~]$ echo `date`
2018年10月21日星期一18:16:33 CST
#反引号括起来的命令会正常执行
[root@localhost ~]$ echo '`date`'
`date`
#但是如果反引号命令被单引号括起来，那么这个命令不会执行，―date会被当成普通字符输出
[root@localhost ~]$ echo "`date`"
2018年10月21日星期一18:14:21 CST
#如果是双引号括起来，那么这个命令又会正常执行
```

#### 反引号

```shell
[root@localhost ~]$ echo ls
ls
#如果命令不用反引号包含，命令不会执行，而是直接输出
[root@localhost ~]$ echo `ls`
anaconda-ks.cfginstall.loginstall.log.syslog sh test testfile
#只有用反引号包括命令，这个命令才会执行
[root@localhost ~]$ echo $(date)
2018年10月21日星期一18:25:09 CST
#使用$(命令)的方式也是可以的
```

### 变量的分类

1. 用户自定义变量：由用户自由定义的变量
2. 环境变量：主要保存的是和系统操作环境相关的数据
3. 位置参数变量：主要是用来向脚本当中传递参数或数据的，变量名不能自定义，作用固定
4. 预定义变量：是Bash中已经定义好的变量，变量名不能自定义，作用固定

#### 变量的查看

```shell
[root@localhost ~]$ set [选项]
选项:
-u:如果设定此选项，调用未声明变量时会报错（默认无任何提示）
-x:如果设定此选项，在命令执行之前，会把命令先输出一次
+<参数> :取消某个set曾启动的参数。

[root@localhost ~]$ set
BASH=/bin/bash
…省略部分输出…
name='shen chao'
#直接使用set 命令，会查询系统中所有的变量，包含用户自定义变量和环境变量
[root@localhost ~]$ set -u
[root@localhost ~]$ echo $file
-bash: file: unbound variable
#当设置了-u选项后，如果调用没有设定的变量会有报错。默认是没有任何输出的。
[root@localhost ~]$ set -x
[root@localhost ~]$ ls
+ls --color=auto
anaconda-ks.cfginstall.loginstall.log.syslog sh tdir testtestfile
#如果设定了-x选项，会在每个命令执行之前，先把命令输出一次

[root@localhost ~]$ set +x
#取消启动的x参数
```

#### 变量删除

```shell
[root@localhost ~]$ unset 变量名
```

### 环境变量

#### 环境变量的设置

```shell
[root@localhost ~]$  export age="18"
#使用export声明的变量即是环境变量
```

#### 环境变量的查询与删除

+ env与set区别：set可以查看所有变量，env只能查看环境变量

```shell
[root@localhost ~]$ unset gender   #删除环境变量gender
[root@localhost ~]$ env | grep gender
```



### 位置参数变量

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| $n           | n为数字，$0表示当前 Shell 脚本程序的名称，$1-9 代 表 第 一 到 第 九 个 参 数 , 十 以 上 的 参 数 需 要 用 大 括 号 包 含 ， 如 9代表第一到第九个参数,十以上的参数需要用大括号包含，如9代表第一到第九个参数,十以上的参数需要用大括号包含，如{10} |
| $*           | 这个变量代表命令行中所有的参数，$把所有的参数看成一个整体    |
| $@           | 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待   |
| $#           | 这个变量代表命令行中所有参数的个数                           |

##### $*与$@

```shell
[root@localhost sh]$ vi parameter2.sh
#!/bin/bash
for i in"$*"
#定义for循环，in后面有几个值，for会循环多少次，注意“$*”要用双引号括起来
#每次循环会把in后面的值赋予变量i
#Shell把$*中的所有参数看成是一个整体，所以这个for循环只会循环一次
	do
		echo "The parameters is: $i"
		#打印变量$i的值
	done
x=1
#定义变量x的值为1,用于跟踪参数的索引
for y in"$@"
#同样in后面的有几个值，for循环几次，每次都把值赋予变量y
#可是Shell中把“$@”中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次
	do
		echo "The parameter$x is: $y"
		#输出变量y的值
		x=$((x +1))
		#然变量x每次循环都加1，为了输出时看的更清楚
	done
```



### 预定义变量

| 预定义变量 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| $?         | 最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行;如果这个变量的值为非0(具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。 |
| $$         | 当前进程的进程号（PID)                                       |
| $!         | 后台运行的最后一个进程的进程号(PID)                          |

### 只读变量

```shell

[root@localhost sh]$ vi readonly.sh
#!/bin/bash
a=10
#语法：readonly 变量名
readonly a
a=20   #会报错readonly variable
echo $a
```

## 键盘输入

```shell
[root@localhost ~]$ read [选项][变量名]
选项:
	-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。
	-p： “提示信息”：在等待read输入时，输出提示信息
	-t： 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间
	-n： 数字：read命令只接受指定的字符数，就会执行
	-s： 隐藏输入的数据，适用于机密信息的输入
    -d： 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。
    -e： 在输入的时候可以使用命令补全功能。
变量名:
变量名可以自定义，如果不指定变量名，会把输入保存入默认变量REPLY.
如果只提供了一个变量名，则整个输入行赋予该变量.
如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字
```

## 四、shell运算符

### 1.算数运算符

| 运算符 | 说明                                            | 举例                            |
| ------ | ----------------------------------------------- | ------------------------------- |
| +      | 加法                                            | `expr $a + $b` 结果为 30。      |
| -      | 减法                                            | `expr $a - $b` 结果为 -10。     |
| *      | 乘法                                            | `expr $a \* $b` 结果为 200。    |
| /      | 除法                                            | `expr $b / $a` 结果为 2。       |
| %      | 取余                                            | `expr $b % $a` 结果为 0。       |
| =      | 赋值                                            | a=$b 将把变量 b 的值赋给 a。    |
| ==     | 相等。用于比较两个数字，相同则返回 true（真）。 | [ $a == $b ] 返回 false（假）。 |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。   | [ $a != $b ] 返回 true。        |

+ 条件表达式要放在方括号之间，并且要有空格，必须写成 ` [ $a == $b ] `

### 2.关系运算符

| 运算符 | 单词                | 说明                                                  |
| ------ | ------------------- | ----------------------------------------------------- |
| -eq    | equal               | 检测两个数是否相等，相等返回 true。                   |
| -ne    | not equal           | 检测两个数是否相等，不相等返回 true。                 |
| -gt    | great than          | 检测左边的数是否大于右边的，如果是，则返回 true。     |
| -lt    | less than           | 检测左边的数是否小于右边的，如果是，则返回 true。     |
| -ge    | great than or equal | 检测左边的数是否大于等于右边的，如果是，则返回 true。 |
| -le    | less than or equal  | 检测左边的数是否小于等于右边的，如果是，则返回 true。 |

### 3.逻辑运算符

| 运算符 | 说明                                                | 举例                                     |
| ------ | --------------------------------------------------- | ---------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |
| -o     | 或（或者）运算，有一个表达式为 true 则返回 true。   | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |
| -a     | 与（并且）运算，两个表达式都为 true 才返回 true。   | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |

### 4.字符串运算符

| 运算符 | 说明                                      | 举例                     |
| ------ | ----------------------------------------- | ------------------------ |
| =      | 检测两个字符串是否相等，相等返回 true。   | [ $a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否相等，不相等返回 true。 | [ $a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。     | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否为0，不为0返回 true。   | [ -n $a ] 返回 true。    |
| str    | 检测字符串是否为空，不为空返回 true。     | [ $a ] 返回 true。       |

### 5.**文件测试运算符**

| 操作符  | 说明                                                         | 举例                      |
| ------- | ------------------------------------------------------------ | ------------------------- |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false   |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false   |
| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false   |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true    |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false   |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false   |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false   |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |
| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |
| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |
| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |



## 五、流程控制

#### 1. if条件判断

##### 1.1 单分支if条件

**语法：**

```shell
if [ 条件判断式 ]
	then
		程序
fi
```

##### 1.2 双分支if条件语句

**语法：**

```shell
if [ 条件判断式 ]
	then
		条件成立时，执行的程序
	else
		条件不成立时，执行的另一个程序
fi
```

##### 1.3 多分支if条件语句

**语法：**

```shell
if [ 条件判断式1 ]
	then
		当条件判断式1成立时，执行程序1
elif [ 条件判断式2 ]
	then
		当条件判断式2成立时，执行程序2
…省略更多条件…
else
	当所有条件都不成立时，最后执行此程序
fi
```

+++

#### 2. 多分支case条件语句

case语句和if…elif…else语句一样都是多分支条件语句,不过和if多分支条件语句不同的是，**case语句只能判断一种条件关系**，而if语句可以判断多种条件关系。

**case语句语法如下:**

```shell
case $变量名 in
	"值1")
	如果变量的值等于值1，则执行程序1
	;;
	"值2")
	如果变量的值等于值2，则执行程序2
	::
	…省略其他分支…
	*)
	如果变量的值都不是以上的值，则执行此程序
	;;
esac
```

这个语句需要注意以下内容:

+ case语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行 “*)” (*代表所有其他值）中的程序。
+ case语句以“case”开头，以“esac”结尾。
  每一个分支程序之后要通过“;;”双分号结尾，代表该程序段结束(千万不要忘记，每次写case语句，都不要忘记双分号）。

+++

#### 3. for循环

for循环是固定循环，也就是在循环时已经知道需要进行几次的循环，有时也把for循环称为计数循环。for的语法有如下两种:

**语法一:**

```shell
for 变量 in 值1 值2 值3 …(可以是一个文件等)
	do
		程序
	done
	
	这种语法中for循环的次数，取决于in后面值的个数（空格分隔），有几个值就循环几次，并且每次循环都把值赋予变量。
	也就是说，假设in后面有三个值，for会循环三次，第一次循环会把值1赋予变量，第二次循环会把值2赋予变量，以此类推。
```

**语法二:**

```shell
for (( 初始值;循环控制条件;变量变化 ))
	do
		程序
	done
	
语法二中需要注意:
初始值:在循环开始时，需要给某个变量赋予初始值，如i=1;

循环控制条件:用于指定变量循环的次数，如i<=100，则只要i的值小于等于100，循环就会继续;

变量变化:每次循环之后，变量该如何变化，如i=i+1。代表每次循环之后，变量i的值都加1。
```

++++

#### 4. while循环

对while循环来讲，只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。

**语法：**

```shell
while [ 条件判断式 ]
	do
		程序
	done
```

+++

#### 5. until循环

和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。

**语法:**

```shell
until [ 条件判断式 ]
	do
		程序
	done
```

++++

#### 6. 函数

**语法：**

```shell
function 函数名 () {
	程序
}
```

+++

#### 7. 特殊流程控制语句

##### 7.1 exit语句

系统是有exit命令的，用于退出当前用户的登录状态。可是在Shell脚本中，exit语句是用来退出当前脚本的。也就是说，**在Shell脚本中，只要碰到了exit语句，后续的程序就不再执行，而直接退出脚本**。

**exit的语法如下:**

```shell
exit [返回值]
```

+ 如果**exit命令之后定义了返回值，那么这个脚本执行之后的返回值就是我们自己定义的返回值。可以通过查询$?这个变量，来查看返回值**。如果exit之后没有定义返回值，脚本执行之后的返回值是执行exit 语句之前，最后执行的一条命令的返回值。

##### 7.2 break语句

当程序执行到break语句时，会结束整个当前循环。而continue 语句也是结束循环的语句，不过continue 语句单次当前循环，而下次循环会继续。

##### 7.3 continue语句

continue也是结束流程控制的语句。如果在循环中，continue语句只会结束单次当前循环。

+++++

### 六、字符截取、替换和处理命令

#### 正则表达式

| 元字符  | 描述                                                 | 示例                                                         |
| ------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| `\`     | 转义符，将特殊字符进行转义，忽略其特殊意义           | `a.b` 匹配 `a.b`，但不能匹配 `ajb`，`.` 被转义为特殊意义     |
| `^`     | 匹配行首，`awk`中，`^`则是匹配字符串的开始           | `^tux` 匹配以 `tux` 开头的行                                 |
| `$`     | 匹配行尾，`awk`中，`$`则是匹配字符串的结尾           | `tux$` 匹配以 `tux` 结尾的行                                 |
| `.`     | 匹配除换行符 `\n` 之外的任意单个字符                 | `ab.` 匹配 `abc` 或 `abd`，不可匹配 `abcd` 或 `abde`，只能匹配单字符 |
| `[ ]`   | 匹配包含在 `[字符]` 之中的任意一个字符               | `coo[kl]` 可以匹配 `cook` 或 `cool`                          |
| `[^]`   | 匹配 `[^字符]` 之外的任意一个字符                    | `123[^45]` 不可以匹配 `1234` 或 `1235`，`1236`、`1237` 都可以 |
| `[-]`   | 匹配 `[]` 中指定范围内的任意一个字符，要写成递增     | `[0-9]` 可以匹配 `1`、`2` 或 `3` 等其中任意一个数字          |
| `?`     | 匹配之前的项 1 次或者 0 次                           | `colou?r` 可以匹配 `color` 或 `colour`，不能匹配 `colouur`   |
| `+`     | 匹配之前的项 1 次或者多次                            | `sa-6+` 匹配 `sa-6`、`sa-666`，不能匹配 `sa-`                |
| `*`     | 匹配之前的项 0 次或者多次                            | `co*l` 匹配 `cl`、`col`、`cool`、`coool` 等                  |
| `()`    | 匹配表达式，创建一个用于匹配的子串                   | `ma(tri)?` 匹配 `max` 或 `maxtrix`                           |
| `{n}`   | 匹配之前的项 `n` 次，`n` 是可以为 0 的正整数         | `[0-9]{3}` 匹配任意一个三位数，可以扩展为 `[0-9][0-9][0-9]`  |
| `{n,}`  | 之前的项至少需要匹配 `n` 次                          | `[0-9]{2,}` 匹配任意一个两位数或更多位数                     |
| `{n,m}` | 指定之前的项至少匹配 `n` 次，最多匹配 `m` 次，`n<=m` | `[0-9]{2,5}` 匹配从两位数到五位数之间的任意一个数字          |
| `|`     | 交替匹配 `|` 两边的任意一项                          | `ab(c|d)` 匹配 `abc` 或 `abd`                                |

#### 1 字符截取、替换命令

##### 1.1 cut 列提取命令

```shell
[root@localhost ~]$ cut [选项] 文件名
选项:
-f 列号: 提取第几列
-d 分隔符: 按照指定分隔符分割列
-n	取消分割多字节字符
-c 字符范围: 不依赖分隔符来区分列，而是通过字符范围（行首为0）来进行字段提取。“n-”表示从第n个字符到行尾;“n-m”从第n个字符到第m个字符;“一m”表示从第1个字符到第m个字符。
--complement	补足被选择的字节、字符或字段
--out-delimiter	指定输出内容是的字段分割符
```

##### 1.2 awk 编程

###### 1.2.1 awk 概述

AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。

###### 1.2.2 printf 格式化输出

```shell
[root@localhost ~]$ printf ‘输出类型输出格式’ 输出内容

输出类型:
%c:     ASCII字符.显示相对应参数的第一个字符
%-ns:   输出字符串，减号“-”表示左对齐(默认右对齐)，n是数字指代输出几个字符,几个参数就写几个%-ns
%-ni:   输出整数，n是数字指代输出几个数字
%f：    输出小数点右边的位数
%m.nf:  输出浮点数，m和n是数字，指代输出的整数位数和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。

输出格式:
\a: 输出警告声音
\b: 输出退格键，也就是Backspace键
\f: 清除屏幕
\n: 换行
\r: 回车，也就是Enter键
\t: 水平输出退格键，也就是Tab 键
\v: 垂直输出退格键，也就是Tab 键
```

###### 1.2.3 awk 基本使用

```shell
[root@localhost ~]$ awk‘条件1{动作1} 条件2{动作2}…’ 文件名
条件（Pattern）:
	一般使用关系表达式作为条件。这些关系表达式非常多，例如:
	x > 10  判断变量x是否大于10
	x == y  判断变量x是否等于变量y
	A ~ B   判断字符串A中是否包含能匹配B表达式的子字符串
	A !~ B  判断字符串A中是否不包含能匹配B表达式的子字符串
	
动作（Action） :
	格式化输出
	流程控制语句

常用参数：

   -F	指定输入时用到的字段分隔符
   -v	自定义变量
   -f	从脚本中读取awk命令
   -m	对val值设置内在限制
```

###### 1.2.4 awk 的条件

|条件的类型	|条件	|说明|
| ------ | ----------------------------------------------- | ------------------------------- |
|awk保留字	|BEGIN	|在awk程序一开始时，尚未读取任何数据之前执行。BEGIN后的动作只在程序开始时执行一次|
|awk保留字	|END	|在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次|
|关系运算符	|>	|大于|
|关系运算符	|<	|小于|
|关系运算符	|>=	|大于等于|
|关系运算符	|<=	|小于等于|
|关系运算符	|==	|等于。用于判断两个值是否相等，如果是给变量赋值，请使用“”号|
|关系运算符	|!=	|不等于|
|关系运算符	|A~B	|判断字符串A中是否包含能匹配B表达式的子字符串|
|关系运算符	|A!~B	|判断字符串A中是否不包含能匹配B表达式的子字符串|
|正则表达式	|/正则/	|如果在"//"中可以写入字符，也可以支持正则表达式|

###### BEGIN

BEGIN是awk的保留字，是一种特殊的条件类型。BEGIN的执行时机是“在 awk程序一开始时，尚未读取任何数据之前执行”。一旦BEGIN后的动作执行一次，当awk开始从文件中读入数据，BEGIN的条件就不再成立，所以BEGIN定义的动作只能被执行一次。
例如:

```shell
[root@localhost ~]$ awk 'BEGIN{printf "This is a transcript \n" } {printf $2 "\t" $6 "\n"}’ student.txt
#awk命令只要检测不到完整的单引号不会执行，所以这个命令的换行不用加入“|”,就是一行命令
#这里定义了两个动作
#第一个动作使用BEGIN条件，所以会在读入文件数据前打印“这是一张成绩单”(只会执行一次)
#第二个动作会打印文件的第二字段和第六字段
```

###### END

END也是awk保留字，不过刚好和BEGIN相反。END是在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次。例如:

```shell
[root@localhost ~]$ awk 'END{printf "The End \n"} {printf $2 "\t" $6 "\n"}’ student.txt
#在输出结尾输入“The End”，这并不是文档本身的内容，而且只会执行一次
```

###### 关系运算符

举几个例子看看关系运算符。假设我想看看平均成绩大于等于87分的学员是谁，就可以这样输入命令:
**例子1:**

```shell
[root@localhost ~]$ cat student.txt | grep -v Name | awk '$6 >= 87 {printf $2 "\n"}'
#使用cat输出文件内容，用grep取反包含“Name”的行
#判断第六字段（平均成绩）大于等于87分的行，如果判断式成立，则打第六列（学员名$2）
```

加入了条件之后，只有条件成立动作才会执行，如果条件不满足，则动作则不运行。通过这个实验，大家可以发现，虽然awk是列提取命令，但是也要按行来读入的。这个**命令的执行过程**是这样的:

**1）如果有BEGIN条件，则先执行BEGIN定义的动作。**
**2）如果没有BEGIN条件，则读入第一行，把第一行的数据依次赋予$0、$1、$2等变量。其中$0代表此行的整体数据，$1代表第一字段，$2代表第二字段。**
**3）依据条件类型判断动作是否执行。如果条件符合，则执行动作，否则读入下一行数据。如果没有条件，则每行都执行动作。**
**4）读入下一行数据，重复执行以上步骤**。

###### 正则表达式

如果要想让awk 识别字符串，必须使用“//”包含，例如:
**例子1:**

```shell
[root@localhost ~]$ awk '/Liming/ {print}’student.txt
#打印Liming的成绩
```

当使用df命令查看分区使用情况是，如果我只想查看真正的系统分区的使用状况，而不想查看光盘和临时分区的使用状况，则可以:

```shell
[root@localhost ~]$ df -h | awk '/sda[O-9]/ {printf $1 "\t" $5 "\n"}’
#查询包含有sda数字的行，并打印第一字段和第五字段
```

###### 1.2.5 awk 内置变量

|awk内置变量	|作用|
|----------------------------------------------------|-------------------------------------|
|$0	|代表目前awk所读入的整行数据。我们已知awk是一行一行读入数据的，$0就代表当前读入行的整行数据。|
|$n	|代表目前读入行的第n个字段。比如，$1表示第1个字段(列)，$2表示第2个字段(列)，如此类推|
|NF	|当前行拥有的字段（列）总数。|
|NR	|当前awk所处理的行，是总数据的第几行。|
|FS	|用户定义分隔符。awk的默认分隔符是任何空格，如果想要使用其他分隔符（如“:”），就需要FS变量定义。|
|ARGC	|命令行参数个数。|
|ARGV	|命令行参数数组。|
|FNR	|当前文件中的当前记录数（对输入文件起始为1）。|
|OFMT	|数值的输出格式（默认为%.6g）。|
|OFS	|输出字段的分隔符（默认为空格）。|
|ORS	|输出记录分隔符（默认为换行符）。|
|RS	|输入记录分隔符（默认为换行符）。|

**awk常用统计实例**

```shell
1、打印文件的第一列(域) ：
 awk '{print $1}' filename
 
2、打印文件的前两列(域) ：
 awk '{print $1,$2}' filename
 
3、打印完第一列，然后打印第二列 ： 
awk '{print $1 $2}' filename

4、打印文本文件的总行数 ： 
awk 'END{print NR}' filename

5、打印文本第一行 ：
awk 'NR==1{print}' filename

6、打印文本第二行第一列 ：
sed -n "2, 1p" filename | awk 'print $1'



1. 获取第一列
ps -aux | grep watchdog | awk '{print $1}'

2. 获取第一列，第二列，第三列
ps -aux | grep watchdog | awk '{print $1, $2, $3}'

3. 获取第一行的第一列，第二列，第三列
ps -aux | grep watchdog | awk 'NR==1{print $1, $2, $3}'

4. 获取行数NR
df -h | awk 'END{print NR}'

5. 获取列数NF（这里是获取最后一行的列数，注意每行的列数可能是不同的）
ps -aux | grep watchdog | awk 'END{print NF}'

6. 获取最后一列
ps -aux | grep watchdog | awk '{print $NF}'

7. 对文件进行操作
awk '{print $1}' fileName

8. 指定分隔符（这里以:分割）
ps -aux | grep watchdog |awk  -F':' '{print $1}'

9. 超出范围不报错
ps -aux | grep watchdog | awk '{print $100}'
```




